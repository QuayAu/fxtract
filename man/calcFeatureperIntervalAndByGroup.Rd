% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calcFeaturePerIntervalAndByGroup.R
\name{calcFeatureperIntervalAndByGroup}
\alias{calcFeatureperIntervalAndByGroup}
\title{Calculates a given function on the dataset for each interval and grouped by a given group.
Needs a function, which has a dataframe as input and a singular value as output.
A summary function, which summarizes the results for each day, will be evaluated for each 'userId'.}
\usage{
calcFeatureperIntervalAndByGroup(data, group_col, fun, colname, summary_fun,
  steps, time_in_sec, unit, export_results_per_interval = FALSE,
  check_fun = TRUE)
}
\arguments{
\item{data}{dataframe.}

\item{group_col}{character. Name of column, which contains identifiers on which the dataset should be grouped by. E.g. different user IDs.}

\item{fun}{function. Must be a function, which has a dataframe as input and a vector (of length nrow(dataframe)) as output.}

\item{colname}{character. Column name of the new column.}

\item{summary_fun}{function. Must be a function, which has a vector as input and a singular value as output.}

\item{steps}{integer. Number of observations, which will be in the intervals.
Use this for data with fixed sample rate. \code{unit} will have no effect, if \code{steps} are chosen.}

\item{time_in_sec}{numeric. Number of seconds, which will be the length of the intervals.
Use this for data with variable sample rate.}

\item{unit}{unit of the timestamps. Can be 's' or 'ms'. Defaults to 's' (seconds).}

\item{export_results_per_interval}{logical. If TRUE, an additional dataframe, where \code{fun} is evaluated at each interval, is returned.}

\item{check_fun}{logical. If \code{TRUE}, fun(data) will be evaluated and checked, 
if the outcome is of correct form. Set to \code{FALSE}, if evaluation on the whole dataset takes too long.}
}
\value{
dataframe with columns userId and \code{colname}. One value for each userId.
}
\description{
Calculates a given function on the dataset for each interval and grouped by a given group.
Needs a function, which has a dataframe as input and a singular value as output.
A summary function, which summarizes the results for each day, will be evaluated for each 'userId'.
}
\examples{
data = studentlife.small \%>\% filter(!is.na(altitude))
fun = function(data) mean(data$altitude, na.rm = TRUE)
summary_fun = function(vector) ar(vector[!is.na(vector)], order.max = 1)$ar

}
\seealso{
Other feature functions: \code{\link{calcFeatureByGroup}},
  \code{\link{calcFeaturePerStudyDayAndByGroup}}
}
