---
title: "Introduction to seRu"
#author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to seRu}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This will be the Get Started page.

<!-- ## How should your data look like? -->

<!-- The data should be a dataframe with following variables: -->

<!-- ### userId -->
<!-- This should be an identifier for each user. -->

<!-- ### source -->
<!-- Data from smartphone logs can be categorized into e.g. PHONE, SMS, APPS, WIFI, BLUETOOTH, etc. -->
<!-- This variable should be an identifier for this category. -->
<!-- For example, all phone related logs, like incoming calls, outgoing calls need to be identified with the variable source = PHONE. -->
<!-- Supported sources are: "AIRPLANE", "APPINST", "APPS", "BLUETOOTH", "BOOT", "CALENDAR", "CAMERA", "CONTACTS", "DEVICEINFO", "GPS", "HEADSET", "MUSIC", "NOTIFICATION", "PHONE", "POWER", "SCREEN", "SETTINGS", "SMS", "WIFI". -->

<!-- We are sure that some logging apps do not take logs from all of these sources. -->
<!-- The package will throw an error if you use a function which depends on a specific source. -->


<!-- ### timestamp and timezoneOffset -->
<!-- This variable is crucial for analyses and must be treated VERY carefully! -->
<!-- The timestamp must be saved in UTC time (Coordinated Universal Time) in **ms**, and the timestamp offset must also be saved in **ms**. -->
<!-- We chose **ms** to make different actions, which take place within one second, distinguishable. -->

<!-- Example: For analysis in central european time CET=UTC+1, the timezoneOffset must be 3600000 (=60\*60\*1\*1000). -->
<!-- For analysis in North American Central Time Zone CST = UTC-6, the timezoneOffset must be -21600000 (=60\*60\*(-6)\*1000) -->

<!-- ### date, time -->
<!-- Please use the lubridate package to extract date and time (both with type character) in the following format: -->

<!-- date: yyyy-mm-dd -->

<!-- time: hh:mm:ss -->

<!-- ### weekday -->
<!-- weekday must be an ordered factor with levels: Mon < Tue < Wed < Thu < Fri < Sat < Sun -->

<!-- This can e.g. be achieved by the lubridate function `wday`: -->

<!-- `wday(as_datetime((phonedata$timestamp + phonedata$timezoneOffset) / 1000),` -->
<!-- `  label = TRUE, week_start = 1, locale = "English_United States.1252"))` -->

<!-- ### apps.packageName -->
<!-- This variable contains the unique app identifier from the google play store. E.g. `com.whatsapp` -->

<!-- ### apps.name -->
<!-- This is not mandatory but recommended for the analysis of app usage behavior. This variable contains the name of used apps. -->
<!-- This variable is language dependent, but the `package_name` variable is not. -->

<!-- ### gps.longitude, gps.latitude -->
<!-- For location analyses the variables longitude and latitude must be given. Both are specified in degrees, not in radians. Rows with valid longitude and latitude should have source = GPS. -->
<!-- It is expected that GPS coordinates, i.e. longitude and latitude, are collected in regular intervals (e.g. every ten or fifteen minutes) during the study participation of the participants. Otherwise the location analyses will return faulty results. -->


<!-- ## How can you work with this package? -->

<!-- ### Overview of available functions -->

<!-- The available functions are grouped in several families (which correspond roughly to the values of the `source` variable, see above), e.g. apps, calendar, camera, communication (phone/SMS) and location (GPS). Also, several generic functions are available which are applicable across different source information. The names of the functions always start with the family name, e.g. `appsUsageTimeCategories` or `genericTimefunctionWeekdays`. In the Help page for each function, in the section "See Also", you can find the other functions from the same family. -->
<!-- Check the function reference for an overview of all available functions. -->

<!-- ### Example for using the package -->
<!-- Please read this example carefully, as it explains several important features of our package. -->

<!-- Say you are interested in evaluating app data. More precisely you want to know how often the study participants used apps in different categories, and what the mean and variance of the app usage time are. -->

<!-- In this case you find the relevant functions starting with `apps` as explained above. -->
<!-- The function `appsNumberUsageCategories` allows you to calculate the number of app usages. You call this function e.g. by -->

<!-- `appsNumberUsageCategories(loggingdata = my_phonelogs, categories = "all")` -->

<!-- In this case, participant IDs will be chosen as all available IDs in the data set, and every app category occurring in the variable `apps.appStoreCategory` will be considered. -->

<!-- This function then returns a dataframe. The first variable consists of the participant IDs, the second variable shows the number of app usages in all categories for the participant IDs. -->
<!-- If you want to consider only some participant IDs and/or app categories, you can call the function e.g. by -->

<!-- `appsNumberUsageCategories(loggingdata = my_phonelogs, ids = c("id1", "id2"), categories = c("Social", "Communication"))` -->

<!-- which returns a dataframe with two rows (corresponding to the two participant IDs, which are shown in the first variable `userId`) and a second variable which shows the number of app usages in the chosen categories for the given participants. -->

<!-- The name of the second variable (which contains the app usage information) can be changed with the argument `colname`. If you want this variable to have the name "NumberAppUsage", call the function by -->

<!-- `appsNumberUsageCategories(loggingdata = my_phonelogs, categories = "all", colname = "NumberAppUsage")` -->

<!-- Please check the function documentation for more information on further arguments. -->

<!-- Next, say you would like to calculate the mean and the variance of the app usage time (in certain app categories) for every participant. You do this by calling the function `appsUsageTimeCategories`. This is a function that allows you to apply different methods to the app usage time (e.g. the mean, variance, sum, max/min), where you specify the desired method in the argument `fun`. -->

<!-- That is, for calculating the mean, call -->

<!-- `appsUsageTimeCategories(loggingdata = my_phonelogs, categories = "all", fun = "mean", colname = "meanUsageTime")` -->

<!-- For calculating the variance, call -->

<!-- `appsUsageTimeCategories(loggingdata = my_phonelogs, categories = "all", fun = "var", colname = "varUsageTime")` -->

<!-- This, again, will return a dataframe with the participant IDs, and a second variable which shows, for every participant ID, the mean usage time or variance of usage time in the chosen categories. -->

<!-- It might be that you get `NA` as the return value for a certain participant. This can e.g. occur if the function was not able to calculate a valid usage time for one or more app usages of this participant. In this case, you might decide to skip these `NA`s and calculate the mean or variance of the valid usage times which are not `NA`. This works by calling -->

<!-- `appsUsageTimeCategories(loggingdata = my_phonelogs, categories = "all", fun = "mean", -->
<!-- colname = "meanUsageTime", na.rm = TRUE)` -->

<!-- Then `na.rm = TRUE` will be passed to the function `mean` as an argument, and therefore usage times that are `NA` will be ignored when calculating the mean. You can specify other additional arguments passed to `fun` in the same way. -->


<!-- As above, the function `appsUsageTimeCategories` accepts other arguments such as `ids`, `colname` etc. Again, check the documentation for more details. -->


<!-- In most functions of our package the return value is a data frame with the participant IDs in the first variable and the information of interest in the second variable, as seen above. This allows you to easily combine results from different functions in one single data frame. For example, if you want a single data frame which contains the participant IDs and, for these IDs, the number of app usages in all app categories as well as mean and variance of app usage time, you might procede like this: -->

<!-- `x = appsNumberUsageCategories(loggingdata = my_phonelogs, categories = "all")` -->

<!-- `x = dplyr::left_join(x, appsUsageTimeCategories(loggingdata = my_phonelogs, categories = "all", fun = "mean", colname = "meanUsageTime", na.rm = TRUE))` -->

<!-- `x = dplyr::left_join(x, appsUsageTimeCategories(loggingdata = my_phonelogs, categories = "all", fun = "var", colname = "varUsageTime", na.rm = TRUE))` -->

<!-- where we use the `left_join` function from the `dplyr` package. This results in a data frame as requested. -->


<!-- ## If you want to contribute to our package: -->

<!-- ### Required knowledge -->
<!-- You must be familiar with the basics of R package programming. These are covered e.g. by Hadley Wickham's book "R packages", available on http://r-pkgs.had.co.nz/. -->

<!-- ### Code style -->
<!-- Please follow the R Style Guide written by Bernd Bischl: https://github.com/rdatsci/PackagesInfo/wiki/R-Style-Guide -->

<!-- ### Unit tests -->
<!-- Always write a unit test for every function you add. The tests are grouped by the thematic categories/families mentioned above (apps, calendar, generic etc). This means we have the files `test_apps`, `test_calendar`, `test_generic` etc. in the folder `tests/testthat/`. Each of these files contains several tests created with `testthat`, where one test always corresponds to one function (e.g. the test `test_that("Apps Usage Time in Categories", {..})` is written for the function `appsUsageTimeCategories`). -->

<!-- ### Other packages which are relevant to ours -->
<!-- We often use the `dplyr package`, so you should be familiar with the most important functions of this package. Knowledge of the pipe `%>%` from the `magrittr` package is also helpful. -->

<!-- When dealing with timestamps and dates it is important to know the `lubridate` package. -->

<!-- If you need a function from a package when writing a new function, put this package in the DESCRIPTION file under Imports or Suggests, and make sure to write `packagename::` before the function (e.g. write `dplyr::filter`, not just `filter` if you want to use the `filter` function from `dplyr` in your new function). -->

<!-- ### Use what is already there -->
<!-- We have a variety of helper functions that implement important and helpful methods which can be used when writing new functions (e.g., the `findFirstEvent` function). You can find these in the files starting with `helper` in the `R` folder. -->
<!-- Also, the preprocessing functions (e.g. `appsPreproc` and `communicationPreproc`) might be helpful. Use these in new functions if it saves code and time. -->

<!-- ### Git -->
<!-- We use Git for version control. Currently we are using Gitlab as the repository hosting service. -->
