---
title: "Use Cases"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fxtract}
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# Introduction to Dataset

See [official site](http://studentlife.cs.dartmouth.edu/dataset.html) for more information.

## studentlife_small
We downloaded gps and app data from three participants of the studentlife dataset.


```{r, message = FALSE, warning = FALSE}
library(fxtract)
library(dplyr)
str(studentlife_small)
```

<!-- # ```{r, message = FALSE, warning = FALSE} -->
<!-- # library(dplyr) -->
<!-- # studentlife_small %>% distinct(userId) -->
<!-- # ``` -->

## Number of different used apps

This is a very straightforward function: 
```{r}
numberDiffApps = function(data) {
  c(numberDiffApps = length(unique(data$RUNNING_TASKS_topActivity_mPackage)))
}
```

That's all we need to calculate the number of different apps used for each participant:

```{r}
feat_data = calc_feature(data = studentlife_small, fun = numberDiffApps, group_col = "userId")
feat_data
```

### Number of different used apps from Monday until Friday 
For this feature, we need to filter the dataset from Monday until Friday:
```{r, message = FALSE, warning = FALSE}
studentlife_small_weekday = studentlife_small %>% 
  add_weekday(utc_col = "timestamp") %>%
  filter(weekday >= "Mon" & weekday <= "Fri")
x = calc_feature(data = studentlife_small_weekday, fun = numberDiffApps, group_col = "userId", colname = "numberDiffAppsWeekday")
feat_data = feat_data %>% left_join(x)
feat_data
```

### Number of different used apps per day
To calculate this feature per day, we need to add date information to the dataset:
```{r, message = FALSE, warning = FALSE}
studentlife_small_date = studentlife_small %>% add_date(utc_col = "timestamp")
```

Now we can calculate this feature per day:
```{r}
x = calc_feature(data = studentlife_small_date, fun = numberDiffApps, group_col = c("userId", "date"))
x[, 1:6]
```

All there is left to do is to apply a mean function on the rows of this dataset. You can do this by specifying a `summarize`-function:
```{r}
x = calc_feature(data = studentlife_small_date, fun = numberDiffApps, group_col = c("userId", "date"), 
  summarize = function(x) mean(x, na.rm = TRUE), colname = "dailyNumberDiffApps")
feat_data = feat_data %>% left_join(x)
feat_data
```


## GPS features
### Total distance covered
Again, we need to define a function, which calculates the total distance covered by the GPS points in a given dataset `data`:

```{r}
library(geosphere)
totalDist = function(data) {
  long = data$longitude
  lat = data$latitude
  c(totalDist = sum(geosphere::distHaversine(cbind(long, lat)), na.rm = TRUE))
}
```

```{r}
x = calc_feature(data = studentlife_small, group_col = "userId", fun = totalDist)
feat_data = feat_data %>% left_join(x, by = "userId")
feat_data 
```


For small projects (small datasets, few features) it's ok to calculate the features like above and join the resulting dataframes with `dplyr::left_join` (or your preferred method). But it becomes very burdensome, if datasets get too big for memory and features (possibly many different ones) must be calculated in chunks and be joined afterwards. We made the experience that single errors (e.g. one feature throws an error on one participant) can stop the whole process. Updating this feature and calculate it again can be quite convoluted because of loops and code bloat (many joins). For larger projects, please use the R6 class `Project`. A use case can be found [here](https://quayau.github.io/fxtract/docs/articles/tutorial/usecase_big_data.html).




